start with a clear domain model, separate business logic from infrastructure concerns, design around use-cases not technical layers, ensure each module has a single focused responsibility, define stable interfaces for all external dependencies, inject dependencies instead of hard-coding them, avoid tight coupling between modules, program to abstractions not concrete implementations, define contracts via interfaces or protocols, design extension points without modifying stable core logic, encapsulate complexity behind simple boundaries, prefer composition over inheritance, structure the system into domain, application, infrastructure, and presentation layers, externalize configuration away from code, avoid mixing business rules with IO operations, keep logic pure when feasible, separate read and write paths when beneficial, use lightweight data structures for pure data transport, implement adapters for external systems, ensure every component has exactly one reason to change, build minimal and stable public APIs, eliminate god-objects and oversized manager classes, prevent leaking of internal details across boundaries, keep all dependencies explicit and avoid global state, design everything for testability from the start, unit-test domain behavior thoroughly, log important events at system edges, treat errors as a part of the public interface, ensure components can be replaced or evolved independently, achieve performance through solid architecture not hacks, document architectural decisions concisely with ADRs, maintain strict separation of concerns and clear boundaries between all layers

  начинаем с формулирования доменной модели, отделяем бизнес-логику от инфраструктурных деталей, проектируем систему вокруг пользовательских сценариев а не технических слоёв, даём каждому модулю одну чёткую ответственность, определяем стабильные интерфейсы для всех внешних зависимостей, внедряем зависимости вместо жёсткого связывания, избегаем плотной связности модулей, программируем против абстракций а не конкретных реализаций, задаём контракты через интерфейсы или протоколы, проектируем точки расширения без изменения устойчивого ядра, инкапсулируем сложность за простыми и понятными границами, предпочитаем композицию наследованию, разделяем систему на слои: домен, приложение, инфраструктура, представление, выносим конфигурацию за пределы кода, избегаем смешивания бизнес-правил и операций ввода-вывода, сохраняем логику максимально чистой там где возможно, разделяем операции чтения и записи когда это целесообразно, используем лёгкие структуры данных для переноса информации, создаём адаптеры для внешних систем, гарантируем что каждый компонент имеет одну единственную причину для изменения, проектируем публичные API минимальными и стабильными, избегаем god-objects и гигантских менеджеров, предотвращаем утечку деталей реализации за пределы модулей, делаем зависимости явными и исключаем глобальные состояния, изначально проектируем код тестируемым, покрываем доменное поведение модульными тестами, логируем важные события на границах системы, рассматриваем ошибки как часть публичного контракта, обеспечиваем возможность замены или эволюции любого компонента независимо от остальных, достигаем производительности архитектурой а не хаотичными оптимизациями, документируем архитектурные решения через краткие ADR, поддерживаем строгие границы и чистое разделение ответственности между всеми слоями
